#include "uart_regs.h"

#define csd_LED_ADDR 0x41200000

.extern csd_main

.data
string:
/*
	.ascii "----------------- LED On Period -----------------"
	.byte 0x0D
	.byte 0x0A
	.ascii "1. 100ms 2. 200ms 3. 300ms 4. 400 ms "
	.byte 0x0D
	.byte 0x0A
	.ascii "5. 500ms 6. 600ms 7. 700ms 8. 1 sec"
	.byte 0x0D
	.byte 0x0A
	.ascii "----------------------------------------------------"
	.byte 0x0D
	.byte 0x0A
*/
	.ascii "Select:"
	.byte 0x20
	.byte 0x00
.text

.align 8

// Our interrupt vector table
csd_entry:
	b csd_reset
	b .
	b .
	b .
	b .
	b .
	b csd_irq
	b .

.global main
.global csd_entry
csd_reset:

uart_init:
	ldr r0,	=slcr_UART_RST_CTRL
	ldr r1, =0x0	//	reset UART
	str r1, [r0]

	ldr r0, =slcr_UART_CLK_CTRL
	ldr r1, =0x1402	// divisor = 0x14 (ref clk = 50MHz), srcsel = 0, CLKACT1 = true, CLKACT0 = false
	str r1, [r0]

	ldr r0, =uart_mode_reg0
	ldr r1, =0x20
	str r1, [r0]

	ldr r0, =uart_Control_reg0
	ldr r1, =0x28	//uart off
	str r1, [r0]

	ldr r0, =uart_Baud_rate_gen_reg0
	ldr r1, =0x3e
	str r1, [r0]

	ldr r0, =uart_Baud_rate_divider_reg0
	ldr r1, =0x6
	str r1, [r0]

	ldr r0, =uart_Control_reg0
	ldr r1, =0x00000117	//uart start
	str r1, [r0]

	ldr r0, =uart_Modem_ctrl_reg0
	ldr r1, [r0]

	ldr r0, =uart_Modem_sts_reg0
	ldr r1, [r0]

	mov pc, lr

uart_print:

	ldr r2, =string

transmit_loop:
	ldr r3, =uart_Channel_sts_reg0
	and r3, r3, #0x8
	cmp r3, #0x8
	bne transmit_loop

	ldrb r4, [r2], #1
	strb r4, [r0]
	cmp r4, #0x00
	bne transmit_loop

	mov pc, lr

main:

	bl uart_init

	ldr r0, =uart_TX_RX_FIFO0
	ldr r1, =uart_Channel_sts_reg0
	ldr r5, =csd_LED_ADDR
	mov r6, #0x1

	bl uart_print

forever:

	// check empty: bit#1 is Rx FIFO empty or not (1: empty, 0: not empty)
	ldr r2, [r1]
	and r2, r2, #1<<1
	cmp r2, #0

	stmfd sp!, {r0-r1}			// Before call csd_main, using stack to save variables
	bleq csd_main
	ldmfd sp!, {r0-r1}			// After call csd_main, loading variables from stack

	// if you type "return" (it seems like
	// only 13 is stored in the buffer, which is "carriage return")
	// so, send "line feed" as well
	cmpeq r3, #13   // 0xD (13) is carriage return in ASCII
	moveq r4, #10 // 0xA (10) is linefeed in ASCII
	streq r4, [r0]

	strb r1, [r0]				// Turn on next LED

	lsl r1, r1, #1				// logical shift left by 1
	cmp r1, #0x100				// compare
	moveq r1, #0x1				// reset LED if compare condition is true

	b forever

recvloop:
	// check empty: bit#1 is Rx FIFO empty or not (1: empty, 0: not empty)
	ldr r2, [r1]
	and r2, r2, #1<<1
	cmp r2, #0

	// read data and transmit it back to sender
	ldreq r3, [r0]
	streq r3, [r0]

	// if you type "return" (it seems like 
	// only 13 is stored in the buffer, which is "carriage return")
	// so, send "line feed" as well
	cmpeq r3, #13   // 0xD (13) is carriage return in ASCII
	moveq r4, #10 // 0xA (10) is linefeed in ASCII
	streq r4, [r0]

	b recvloop


csd_irq:
	b .
